<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TI-ONP | TI Open Network Protocol: netpktce.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TI-ONP | TI Open Network Protocol
   &#160;<span id="projectnumber">1</span>
   </div>
   <div id="projectbrief">An implementation of a network packetization protocol for the TI-84+ CE graphing calculator. This project is unaffiliated with TI in any way. It is a custom, 3rd party, open-source protocol for sending data using the 3rd party SRLDRVCE (and other) libraries.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">netpktce.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Defines the implementation of TI-ONP.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;srldrvce.h&gt;</code><br />
</div>
<p><a href="netpktce_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a9042337dc2546d731f941e3c259d60da"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="netpktce_8h.html#a9042337dc2546d731f941e3c259d60da">_device_types</a> { <a class="el" href="netpktce_8h.html#a9042337dc2546d731f941e3c259d60daa50c30a23dea6c506c49b17b601ae2c4e">DEVICE_NONE</a>
, <a class="el" href="netpktce_8h.html#a9042337dc2546d731f941e3c259d60daab688adfab6d611ae877ccb76b8f86d7a">DEVICE_SERIAL</a>
 }</td></tr>
<tr class="separator:a9042337dc2546d731f941e3c259d60da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a49f3c0ed09ccd67b4f0345e99ed4471d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="netpktce_8h.html#a49f3c0ed09ccd67b4f0345e99ed4471d">pl_SetDevice</a> (uint8_t dev_type, void *dev_ref, size_t buf_len)</td></tr>
<tr class="memdesc:a49f3c0ed09ccd67b4f0345e99ed4471d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves internally a reference to an initialized networking device for transmission.  <a href="netpktce_8h.html#a49f3c0ed09ccd67b4f0345e99ed4471d">More...</a><br /></td></tr>
<tr class="separator:a49f3c0ed09ccd67b4f0345e99ed4471d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58df8f84f50f72a2c62bd452d58a3ab"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="netpktce_8h.html#ae58df8f84f50f72a2c62bd452d58a3ab">pl_GetAsyncProcHandler</a> (void)</td></tr>
<tr class="memdesc:ae58df8f84f50f72a2c62bd452d58a3ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the internal device events handler.  <a href="netpktce_8h.html#ae58df8f84f50f72a2c62bd452d58a3ab">More...</a><br /></td></tr>
<tr class="separator:ae58df8f84f50f72a2c62bd452d58a3ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17665c1c86d5ee8e5c1b9aa60319e6c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="netpktce_8h.html#a17665c1c86d5ee8e5c1b9aa60319e6c8">pl_InitSendQueue</a> (uint8_t *queue_buf, size_t queue_len)</td></tr>
<tr class="memdesc:a17665c1c86d5ee8e5c1b9aa60319e6c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an optional send queue for outgoing messages.  <a href="netpktce_8h.html#a17665c1c86d5ee8e5c1b9aa60319e6c8">More...</a><br /></td></tr>
<tr class="separator:a17665c1c86d5ee8e5c1b9aa60319e6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add53d8afeafa25f9094a809a4bbf12f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="netpktce_8h.html#add53d8afeafa25f9094a809a4bbf12f2">pl_QueueSendPacketSegment</a> (uint8_t *data, size_t len)</td></tr>
<tr class="memdesc:add53d8afeafa25f9094a809a4bbf12f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a packet segment to the send queue.  <a href="netpktce_8h.html#add53d8afeafa25f9094a809a4bbf12f2">More...</a><br /></td></tr>
<tr class="separator:add53d8afeafa25f9094a809a4bbf12f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4938b78991b6ce642e2e289db0183bc4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="netpktce_8h.html#a4938b78991b6ce642e2e289db0183bc4">pl_SendPacket</a> (uint8_t *data, size_t len)</td></tr>
<tr class="memdesc:a4938b78991b6ce642e2e289db0183bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a packet or sends the the contents of the send queue.  <a href="netpktce_8h.html#a4938b78991b6ce642e2e289db0183bc4">More...</a><br /></td></tr>
<tr class="separator:a4938b78991b6ce642e2e289db0183bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c78695f43c39502f3e01928acd0571b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="netpktce_8h.html#a2c78695f43c39502f3e01928acd0571b">pl_ReadPacket</a> (uint8_t *dest)</td></tr>
<tr class="memdesc:a2c78695f43c39502f3e01928acd0571b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a number of bytes from the subsystem.  <a href="netpktce_8h.html#a2c78695f43c39502f3e01928acd0571b">More...</a><br /></td></tr>
<tr class="separator:a2c78695f43c39502f3e01928acd0571b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8675f6b874c0de4ef902363e22441dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="netpktce_8h.html#ad8675f6b874c0de4ef902363e22441dd">pl_SetAsyncTimeout</a> (size_t timeout)</td></tr>
<tr class="memdesc:ad8675f6b874c0de4ef902363e22441dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the timeout for the Async device process handler.  <a href="netpktce_8h.html#ad8675f6b874c0de4ef902363e22441dd">More...</a><br /></td></tr>
<tr class="separator:ad8675f6b874c0de4ef902363e22441dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eee61cca8169f57e0f216e562012aa6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="netpktce_8h.html#a3eee61cca8169f57e0f216e562012aa6">pl_SetReadTimeout</a> (size_t timeout)</td></tr>
<tr class="memdesc:a3eee61cca8169f57e0f216e562012aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the timeout for reading a packet.  <a href="netpktce_8h.html#a3eee61cca8169f57e0f216e562012aa6">More...</a><br /></td></tr>
<tr class="separator:a3eee61cca8169f57e0f216e562012aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Defines the implementation of TI-ONP. </p>
<p>TI-ONP is an acronym for TI Open Network Protocol. It is a bare-bones open-source protocol for sending packets to a connected host using some networking device.</p>
<p>Provides an implementation of a basic packetization standard for the TI-84+ CE. The "standard" is simply:</p><ul>
<li>3-byte size word indicating frame length (cannot be larger than the max packet size specified during Initialization)</li>
<li>The data section of arbitrary (but bounded) length.</li>
<li>* subject to change if more header data is needed</li>
</ul>
<dl class="section author"><dt>Author</dt><dd>Anthony <em>ACagliano</em> Cagliano </dd></dl>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a9042337dc2546d731f941e3c259d60da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9042337dc2546d731f941e3c259d60da">&#9670;&nbsp;</a></span>_device_types</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="netpktce_8h.html#a9042337dc2546d731f941e3c259d60da">_device_types</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9042337dc2546d731f941e3c259d60daa50c30a23dea6c506c49b17b601ae2c4e"></a>DEVICE_NONE&#160;</td><td class="fielddoc"><p>indicates that no device is set. This is a default state. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9042337dc2546d731f941e3c259d60daab688adfab6d611ae877ccb76b8f86d7a"></a>DEVICE_SERIAL&#160;</td><td class="fielddoc"><p>specifees the Serial/USB subsystem to be used for networking. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a49f3c0ed09ccd67b4f0345e99ed4471d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f3c0ed09ccd67b4f0345e99ed4471d">&#9670;&nbsp;</a></span>pl_SetDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pl_SetDevice </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dev_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buf_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves internally a reference to an initialized networking device for transmission. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_type</td><td>Specifies the type of device to use. Use the values from <b>enum</b> <b>_device_types</b>. </td></tr>
    <tr><td class="paramname">dev_ref</td><td>Pointer to the device reference structure. (Ex: <em>srl_device_t*</em> for serial) </td></tr>
    <tr><td class="paramname">buf_len</td><td>Size of the internal buffer reserved for the specified device (Ex: for serial, the total size of the serial buffer). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Here is an example of code, showing what the arguments mean: <div class="fragment"><div class="line"><span class="comment">// usb init stuff</span></div>
<div class="line">srl_device_t srl_dev;</div>
<div class="line">uint8_t srl[4096];</div>
<div class="line"><span class="keywordflow">if</span>( srl_Open(&amp;srl_dev, usb_dev, srl, 4096, SRL_INTERFACE_ANY, 9600 ) <span class="keywordflow">return</span> 0;</div>
<div class="line"><span class="keywordflow">if</span>( !<a class="code" href="netpktce_8h.html#a49f3c0ed09ccd67b4f0345e99ed4471d">pl_SetDevice</a>(<a class="code" href="netpktce_8h.html#a9042337dc2546d731f941e3c259d60daab688adfab6d611ae877ccb76b8f86d7a">DEVICE_SERIAL</a>, &amp;srl_dev, 4096) ) <span class="keywordflow">return</span> 0;</div>
<div class="line"><span class="comment">// continue with the packet lib</span></div>
<div class="ttc" id="anetpktce_8h_html_a49f3c0ed09ccd67b4f0345e99ed4471d"><div class="ttname"><a href="netpktce_8h.html#a49f3c0ed09ccd67b4f0345e99ed4471d">pl_SetDevice</a></div><div class="ttdeci">bool pl_SetDevice(uint8_t dev_type, void *dev_ref, size_t buf_len)</div><div class="ttdoc">Saves internally a reference to an initialized networking device for transmission.</div></div>
<div class="ttc" id="anetpktce_8h_html_a9042337dc2546d731f941e3c259d60daab688adfab6d611ae877ccb76b8f86d7a"><div class="ttname"><a href="netpktce_8h.html#a9042337dc2546d731f941e3c259d60daab688adfab6d611ae877ccb76b8f86d7a">DEVICE_SERIAL</a></div><div class="ttdeci">@ DEVICE_SERIAL</div><div class="ttdef"><b>Definition:</b> netpktce.h:31</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ae58df8f84f50f72a2c62bd452d58a3ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae58df8f84f50f72a2c62bd452d58a3ab">&#9670;&nbsp;</a></span>pl_GetAsyncProcHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* pl_GetAsyncProcHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the internal device events handler. </p>
<p>Due to lack of interrupt support on the TI-84+ CE, in some cases you may be required to call an event handler stub in a tick-loop. In this case, return and use a function pointer like so. Note that because the handler may sometimes be NULL (no handler) you should check if the hander is not NULL before trying to call it. </p><div class="fragment"><div class="line">void (*handler)(<span class="keywordtype">bool</span> block) = <a class="code" href="netpktce_8h.html#ae58df8f84f50f72a2c62bd452d58a3ab">pl_GetAsyncProcHandler</a>();</div>
<div class="line"><span class="keywordflow">if</span>(handler) handler(<span class="keyword">true</span>|<span class="keyword">false</span>)</div>
<div class="ttc" id="anetpktce_8h_html_ae58df8f84f50f72a2c62bd452d58a3ab"><div class="ttname"><a href="netpktce_8h.html#ae58df8f84f50f72a2c62bd452d58a3ab">pl_GetAsyncProcHandler</a></div><div class="ttdeci">void * pl_GetAsyncProcHandler(void)</div><div class="ttdoc">Returns a pointer to the internal device events handler.</div></div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>The handler parameter specifies if the call to the async process handler should be blocking or non-blocking. Non-blocking runs once and then returns. Blocking runs for the set timeout (default of 50ms). </dd>
<dd>
This library will call the handler function in its own at some points, namely during <a class="el" href="netpktce_8h.html#a4938b78991b6ce642e2e289db0183bc4" title="Sends a packet or sends the the contents of the send queue.">pl_SendPacket()</a> and <a class="el" href="netpktce_8h.html#a2c78695f43c39502f3e01928acd0571b" title="Reads a number of bytes from the subsystem.">pl_ReadPacket()</a>. If you have no need for consistent device processing, you can probably rely on the library's calling of it; however if you are coding a more dynamic networking application that exchanges large quantities of data, it may be helpful to tick it yourself, even if it may not be needed, simply to ensure that you are emptying out your send and receive buffers as quickly as possible. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the internal asyncronous subsystem event handler that can be run in blocking or non-blocking mode. For USB/Serial, a pointer a function that loops usb_HandleEvents() (either once or for a timeout). </dd></dl>

</div>
</div>
<a id="a17665c1c86d5ee8e5c1b9aa60319e6c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17665c1c86d5ee8e5c1b9aa60319e6c8">&#9670;&nbsp;</a></span>pl_InitSendQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pl_InitSendQueue </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>queue_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>queue_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an optional send queue for outgoing messages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue_buf</td><td>Pointer to a buffer to use as the outgoing message queue. </td></tr>
    <tr><td class="paramname">queue_len</td><td>Length of the <b>queue_buf</b>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Assert <b>queue_len</b> &gt;= (( <b>buf_len</b> / 2 ) - 3). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="netpktce_8h.html#a49f3c0ed09ccd67b4f0345e99ed4471d" title="Saves internally a reference to an initialized networking device for transmission.">pl_SetDevice()</a>. </dd></dl>

</div>
</div>
<a id="add53d8afeafa25f9094a809a4bbf12f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add53d8afeafa25f9094a809a4bbf12f2">&#9670;&nbsp;</a></span>pl_QueueSendPacketSegment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pl_QueueSendPacketSegment </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a packet segment to the send queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to the data to write to the queue. </td></tr>
    <tr><td class="paramname">len</td><td>Length of <b>data</b>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if success. False if failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The queue is used to contruct a single packet, not to queue multiple packets. When you have queued all segments of a packet, then do: <div class="fragment"><div class="line"><a class="code" href="netpktce_8h.html#a4938b78991b6ce642e2e289db0183bc4">pl_SendPacket</a>(NULL, 0);</div>
<div class="ttc" id="anetpktce_8h_html_a4938b78991b6ce642e2e289db0183bc4"><div class="ttname"><a href="netpktce_8h.html#a4938b78991b6ce642e2e289db0183bc4">pl_SendPacket</a></div><div class="ttdeci">size_t pl_SendPacket(uint8_t *data, size_t len)</div><div class="ttdoc">Sends a packet or sends the the contents of the send queue.</div></div>
</div><!-- fragment --> to send the queue. It will empty out the queue, reset its length to 0, and await new packet segments. </dd></dl>

</div>
</div>
<a id="a4938b78991b6ce642e2e289db0183bc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4938b78991b6ce642e2e289db0183bc4">&#9670;&nbsp;</a></span>pl_SendPacket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t pl_SendPacket </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a packet or sends the the contents of the send queue. </p>
<p>Attempts to send data via the whatever device is passed in <a class="el" href="netpktce_8h.html#a49f3c0ed09ccd67b4f0345e99ed4471d" title="Saves internally a reference to an initialized networking device for transmission.">pl_SetDevice()</a>. Determines the maximum packet size, and breaks the input into multiple frames. Each "frame" starts a blocking asyncronous event handler with a timeout of 50ms, giving the device time to clear out any backlog in the send buffer. After this timeout, a 3-byte size word, followed by the frame data is written to the output buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to the buffer containing the packet to send. Alternatively, <b>NULL</b> to send the queue. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the packet at <b>data</b>. Can be 0 if <b>data</b> is NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the packet sent. Will loop sending multiple packet frames until the passed buffer or queue is fully sent or an error occurs. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If at any point a frame reports that the number of bytes sent does not match what is expected, an error, namely buffer limit, is assumed to have occured. The packet send loop immediately breaks, returning the size that was successfully sent. It is up to the user if it is important to them to check for this error condition or if it can simply be ignored. </dd></dl>

</div>
</div>
<a id="a2c78695f43c39502f3e01928acd0571b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c78695f43c39502f3e01928acd0571b">&#9670;&nbsp;</a></span>pl_ReadPacket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pl_ReadPacket </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a number of bytes from the subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to a buffer to read bytes to. Must be large enough to hold the largest packet your use case uses.. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function defaults to a non-blocking read, meaning it checks if there is a full packet available in the receive buffer and then immediately returns to the caller. You may set this to a blocking read by using the <a class="el" href="netpktce_8h.html#a3eee61cca8169f57e0f216e562012aa6" title="Sets the timeout for reading a packet.">pl_SetReadTimeout()</a> function. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if a packet is available. False if not. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Because the header contains a size word, there is no need to pass a read size. The protocol will alternate between attempting to read a <b>size_t</b> (3 bytes) and attempting to read the length the last size_t indicated. </dd></dl>

</div>
</div>
<a id="ad8675f6b874c0de4ef902363e22441dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8675f6b874c0de4ef902363e22441dd">&#9670;&nbsp;</a></span>pl_SetAsyncTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pl_SetAsyncTimeout </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the timeout for the Async device process handler. </p>
<dl class="section note"><dt>Note</dt><dd>The async handler is invoked once when <a class="el" href="netpktce_8h.html#a4938b78991b6ce642e2e289db0183bc4" title="Sends a packet or sends the the contents of the send queue.">pl_SendPacket()</a> is called. It can also be invoked by the user after returning <a class="el" href="netpktce_8h.html#ae58df8f84f50f72a2c62bd452d58a3ab" title="Returns a pointer to the internal device events handler.">pl_GetAsyncProcHandler()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The timeout to set, in milliseconds. Pass 0 to set non-blocking. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3eee61cca8169f57e0f216e562012aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eee61cca8169f57e0f216e562012aa6">&#9670;&nbsp;</a></span>pl_SetReadTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pl_SetReadTimeout </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the timeout for reading a packet. </p>
<dl class="section note"><dt>Note</dt><dd>The async handler is invoked once when <a class="el" href="netpktce_8h.html#a4938b78991b6ce642e2e289db0183bc4" title="Sends a packet or sends the the contents of the send queue.">pl_SendPacket()</a> is called. It can also be invoked by the user after returning <a class="el" href="netpktce_8h.html#ae58df8f84f50f72a2c62bd452d58a3ab" title="Returns a pointer to the internal device events handler.">pl_GetAsyncProcHandler()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The timeout to set, in milliseconds. Pass 0 to set non-blocking. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
