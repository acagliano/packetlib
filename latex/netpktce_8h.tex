\hypertarget{netpktce_8h}{}\doxysection{netpktce.\+h File Reference}
\label{netpktce_8h}\index{netpktce.h@{netpktce.h}}


Defines the implementation of TI-\/\+ONP.  


{\ttfamily \#include $<$stddef.\+h$>$}\newline
{\ttfamily \#include $<$stdbool.\+h$>$}\newline
{\ttfamily \#include $<$srldrvce.\+h$>$}\newline
\doxysubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \mbox{\hyperlink{netpktce_8h_a9042337dc2546d731f941e3c259d60da}{\+\_\+device\+\_\+types}} \{ \mbox{\hyperlink{netpktce_8h_a9042337dc2546d731f941e3c259d60daa50c30a23dea6c506c49b17b601ae2c4e}{DEVICE\+\_\+\+NONE}}
, \mbox{\hyperlink{netpktce_8h_a9042337dc2546d731f941e3c259d60daab688adfab6d611ae877ccb76b8f86d7a}{DEVICE\+\_\+\+SERIAL}}
 \}
\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
bool \mbox{\hyperlink{netpktce_8h_a49f3c0ed09ccd67b4f0345e99ed4471d}{pl\+\_\+\+Set\+Device}} (uint8\+\_\+t dev\+\_\+type, void $\ast$dev\+\_\+ref, size\+\_\+t buf\+\_\+len)
\begin{DoxyCompactList}\small\item\em Saves internally a reference to an initialized networking device for transmission. \end{DoxyCompactList}\item 
void $\ast$ \mbox{\hyperlink{netpktce_8h_ae58df8f84f50f72a2c62bd452d58a3ab}{pl\+\_\+\+Get\+Async\+Proc\+Handler}} (void)
\begin{DoxyCompactList}\small\item\em Returns a pointer to the internal device events handler. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{netpktce_8h_a17665c1c86d5ee8e5c1b9aa60319e6c8}{pl\+\_\+\+Init\+Send\+Queue}} (uint8\+\_\+t $\ast$queue\+\_\+buf, size\+\_\+t queue\+\_\+len)
\begin{DoxyCompactList}\small\item\em Initializes an optional send queue for outgoing messages. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{netpktce_8h_add53d8afeafa25f9094a809a4bbf12f2}{pl\+\_\+\+Queue\+Send\+Packet\+Segment}} (uint8\+\_\+t $\ast$data, size\+\_\+t len)
\begin{DoxyCompactList}\small\item\em Writes a packet segment to the send queue. \end{DoxyCompactList}\item 
size\+\_\+t \mbox{\hyperlink{netpktce_8h_a4938b78991b6ce642e2e289db0183bc4}{pl\+\_\+\+Send\+Packet}} (uint8\+\_\+t $\ast$data, size\+\_\+t len)
\begin{DoxyCompactList}\small\item\em Sends a packet or sends the the contents of the send queue. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{netpktce_8h_a2c78695f43c39502f3e01928acd0571b}{pl\+\_\+\+Read\+Packet}} (uint8\+\_\+t $\ast$dest)
\begin{DoxyCompactList}\small\item\em Reads a number of bytes from the subsystem. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{netpktce_8h_ad8675f6b874c0de4ef902363e22441dd}{pl\+\_\+\+Set\+Async\+Timeout}} (size\+\_\+t timeout)
\begin{DoxyCompactList}\small\item\em Sets the timeout for the Async device process handler. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{netpktce_8h_a3eee61cca8169f57e0f216e562012aa6}{pl\+\_\+\+Set\+Read\+Timeout}} (size\+\_\+t timeout)
\begin{DoxyCompactList}\small\item\em Sets the timeout for reading a packet. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Defines the implementation of TI-\/\+ONP. 

TI-\/\+ONP is an acronym for TI Open Network Protocol. It is a bare-\/bones open-\/source protocol for sending packets to a connected host using some networking device.

Provides an implementation of a basic packetization standard for the TI-\/84+ CE. The \char`\"{}standard\char`\"{} is simply\+:
\begin{DoxyItemize}
\item 3-\/byte size word indicating frame length (cannot be larger than the max packet size specified during Initialization)
\item The data section of arbitrary (but bounded) length.
\item $\ast$ subject to change if more header data is needed
\end{DoxyItemize}

\begin{DoxyAuthor}{Author}
Anthony {\itshape ACagliano} Cagliano 
\end{DoxyAuthor}


\doxysubsection{Enumeration Type Documentation}
\mbox{\Hypertarget{netpktce_8h_a9042337dc2546d731f941e3c259d60da}\label{netpktce_8h_a9042337dc2546d731f941e3c259d60da}} 
\index{netpktce.h@{netpktce.h}!\_device\_types@{\_device\_types}}
\index{\_device\_types@{\_device\_types}!netpktce.h@{netpktce.h}}
\doxysubsubsection{\texorpdfstring{\_device\_types}{\_device\_types}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{netpktce_8h_a9042337dc2546d731f941e3c259d60da}{\+\_\+device\+\_\+types}}}

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{DEVICE\_NONE@{DEVICE\_NONE}!netpktce.h@{netpktce.h}}\index{netpktce.h@{netpktce.h}!DEVICE\_NONE@{DEVICE\_NONE}}}\mbox{\Hypertarget{netpktce_8h_a9042337dc2546d731f941e3c259d60daa50c30a23dea6c506c49b17b601ae2c4e}\label{netpktce_8h_a9042337dc2546d731f941e3c259d60daa50c30a23dea6c506c49b17b601ae2c4e}} 
DEVICE\+\_\+\+NONE&indicates that no device is set. This is a default state. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{DEVICE\_SERIAL@{DEVICE\_SERIAL}!netpktce.h@{netpktce.h}}\index{netpktce.h@{netpktce.h}!DEVICE\_SERIAL@{DEVICE\_SERIAL}}}\mbox{\Hypertarget{netpktce_8h_a9042337dc2546d731f941e3c259d60daab688adfab6d611ae877ccb76b8f86d7a}\label{netpktce_8h_a9042337dc2546d731f941e3c259d60daab688adfab6d611ae877ccb76b8f86d7a}} 
DEVICE\+\_\+\+SERIAL&specifees the Serial/\+USB subsystem to be used for networking. \\
\hline

\end{DoxyEnumFields}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{netpktce_8h_a49f3c0ed09ccd67b4f0345e99ed4471d}\label{netpktce_8h_a49f3c0ed09ccd67b4f0345e99ed4471d}} 
\index{netpktce.h@{netpktce.h}!pl\_SetDevice@{pl\_SetDevice}}
\index{pl\_SetDevice@{pl\_SetDevice}!netpktce.h@{netpktce.h}}
\doxysubsubsection{\texorpdfstring{pl\_SetDevice()}{pl\_SetDevice()}}
{\footnotesize\ttfamily bool pl\+\_\+\+Set\+Device (\begin{DoxyParamCaption}\item[{uint8\+\_\+t}]{dev\+\_\+type,  }\item[{void $\ast$}]{dev\+\_\+ref,  }\item[{size\+\_\+t}]{buf\+\_\+len }\end{DoxyParamCaption})}



Saves internally a reference to an initialized networking device for transmission. 


\begin{DoxyParams}{Parameters}
{\em dev\+\_\+type} & Specifies the type of device to use. Use the values from {\bfseries{enum}} {\bfseries{\+\_\+device\+\_\+types}}. \\
\hline
{\em dev\+\_\+ref} & Pointer to the device reference structure. (Ex\+: {\itshape srl\+\_\+device\+\_\+t$\ast$} for serial) \\
\hline
{\em buf\+\_\+len} & Size of the internal buffer reserved for the specified device (Ex\+: for serial, the total size of the serial buffer). \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
Here is an example of code, showing what the arguments mean\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// usb init stuff}}
\DoxyCodeLine{srl\_device\_t srl\_dev;}
\DoxyCodeLine{uint8\_t srl[4096];}
\DoxyCodeLine{\textcolor{keywordflow}{if}( srl\_Open(\&srl\_dev, usb\_dev, srl, 4096, SRL\_INTERFACE\_ANY, 9600 ) \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\textcolor{keywordflow}{if}( !\mbox{\hyperlink{netpktce_8h_a49f3c0ed09ccd67b4f0345e99ed4471d}{pl\_SetDevice}}(\mbox{\hyperlink{netpktce_8h_a9042337dc2546d731f941e3c259d60daab688adfab6d611ae877ccb76b8f86d7a}{DEVICE\_SERIAL}}, \&srl\_dev, 4096) ) \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\textcolor{comment}{// continue with the packet lib}}

\end{DoxyCode}
 
\end{DoxyNote}
\mbox{\Hypertarget{netpktce_8h_ae58df8f84f50f72a2c62bd452d58a3ab}\label{netpktce_8h_ae58df8f84f50f72a2c62bd452d58a3ab}} 
\index{netpktce.h@{netpktce.h}!pl\_GetAsyncProcHandler@{pl\_GetAsyncProcHandler}}
\index{pl\_GetAsyncProcHandler@{pl\_GetAsyncProcHandler}!netpktce.h@{netpktce.h}}
\doxysubsubsection{\texorpdfstring{pl\_GetAsyncProcHandler()}{pl\_GetAsyncProcHandler()}}
{\footnotesize\ttfamily void$\ast$ pl\+\_\+\+Get\+Async\+Proc\+Handler (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Returns a pointer to the internal device events handler. 

Due to lack of interrupt support on the TI-\/84+ CE, in some cases you may be required to call an event handler stub in a tick-\/loop. In this case, return and use a function pointer like so. Note that because the handler may sometimes be NULL (no handler) you should check if the hander is not NULL before trying to call it. 
\begin{DoxyCode}{0}
\DoxyCodeLine{void (*handler)(\textcolor{keywordtype}{bool} block) = \mbox{\hyperlink{netpktce_8h_ae58df8f84f50f72a2c62bd452d58a3ab}{pl\_GetAsyncProcHandler}}();}
\DoxyCodeLine{\textcolor{keywordflow}{if}(handler) handler(\textcolor{keyword}{true}|\textcolor{keyword}{false})}

\end{DoxyCode}
 \begin{DoxyNote}{Note}
The handler parameter specifies if the call to the async process handler should be blocking or non-\/blocking. Non-\/blocking runs once and then returns. Blocking runs for the set timeout (default of 50ms). 

This library will call the handler function on its own at some points, namely during \mbox{\hyperlink{netpktce_8h_a4938b78991b6ce642e2e289db0183bc4}{pl\+\_\+\+Send\+Packet()}} and \mbox{\hyperlink{netpktce_8h_a2c78695f43c39502f3e01928acd0571b}{pl\+\_\+\+Read\+Packet()}}. If you have no need for consistent device processing, you can probably rely on the library\textquotesingle{}s calling of it; however if you are coding a more dynamic networking application that exchanges large quantities of data, it may be helpful to tick it yourself, even if it may not be needed, simply to ensure that you are emptying out your send and receive buffers as quickly as possible. 
\end{DoxyNote}
\begin{DoxyReturn}{Returns}
Pointer to the internal asyncronous subsystem event handler that can be run in blocking or non-\/blocking mode. For USB/\+Serial, a pointer to a function that loops usb\+\_\+\+Handle\+Events() (either once or for a timeout). 
\end{DoxyReturn}
\mbox{\Hypertarget{netpktce_8h_a17665c1c86d5ee8e5c1b9aa60319e6c8}\label{netpktce_8h_a17665c1c86d5ee8e5c1b9aa60319e6c8}} 
\index{netpktce.h@{netpktce.h}!pl\_InitSendQueue@{pl\_InitSendQueue}}
\index{pl\_InitSendQueue@{pl\_InitSendQueue}!netpktce.h@{netpktce.h}}
\doxysubsubsection{\texorpdfstring{pl\_InitSendQueue()}{pl\_InitSendQueue()}}
{\footnotesize\ttfamily bool pl\+\_\+\+Init\+Send\+Queue (\begin{DoxyParamCaption}\item[{uint8\+\_\+t $\ast$}]{queue\+\_\+buf,  }\item[{size\+\_\+t}]{queue\+\_\+len }\end{DoxyParamCaption})}



Initializes an optional send queue for outgoing messages. 


\begin{DoxyParams}{Parameters}
{\em queue\+\_\+buf} & Pointer to a buffer to use as the outgoing message queue. \\
\hline
{\em queue\+\_\+len} & Length of the {\bfseries{queue\+\_\+buf}}. \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
Assert {\bfseries{queue\+\_\+len}} $>$= (( {\bfseries{buf\+\_\+len}} / 2 ) -\/ 3). 
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{netpktce_8h_a49f3c0ed09ccd67b4f0345e99ed4471d}{pl\+\_\+\+Set\+Device()}}. 
\end{DoxySeeAlso}
\mbox{\Hypertarget{netpktce_8h_add53d8afeafa25f9094a809a4bbf12f2}\label{netpktce_8h_add53d8afeafa25f9094a809a4bbf12f2}} 
\index{netpktce.h@{netpktce.h}!pl\_QueueSendPacketSegment@{pl\_QueueSendPacketSegment}}
\index{pl\_QueueSendPacketSegment@{pl\_QueueSendPacketSegment}!netpktce.h@{netpktce.h}}
\doxysubsubsection{\texorpdfstring{pl\_QueueSendPacketSegment()}{pl\_QueueSendPacketSegment()}}
{\footnotesize\ttfamily bool pl\+\_\+\+Queue\+Send\+Packet\+Segment (\begin{DoxyParamCaption}\item[{uint8\+\_\+t $\ast$}]{data,  }\item[{size\+\_\+t}]{len }\end{DoxyParamCaption})}



Writes a packet segment to the send queue. 


\begin{DoxyParams}{Parameters}
{\em data} & Pointer to the data to write to the queue. \\
\hline
{\em len} & Length of {\bfseries{data}}. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if success. False if failure. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The queue is used to contruct a single packet, not to queue multiple packets. When you have queued all segments of a packet, then do\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{netpktce_8h_a4938b78991b6ce642e2e289db0183bc4}{pl\_SendPacket}}(NULL, 0);}

\end{DoxyCode}
 to send the queue. It will empty out the queue, reset its length to 0, and await new packet segments. 
\end{DoxyNote}
\mbox{\Hypertarget{netpktce_8h_a4938b78991b6ce642e2e289db0183bc4}\label{netpktce_8h_a4938b78991b6ce642e2e289db0183bc4}} 
\index{netpktce.h@{netpktce.h}!pl\_SendPacket@{pl\_SendPacket}}
\index{pl\_SendPacket@{pl\_SendPacket}!netpktce.h@{netpktce.h}}
\doxysubsubsection{\texorpdfstring{pl\_SendPacket()}{pl\_SendPacket()}}
{\footnotesize\ttfamily size\+\_\+t pl\+\_\+\+Send\+Packet (\begin{DoxyParamCaption}\item[{uint8\+\_\+t $\ast$}]{data,  }\item[{size\+\_\+t}]{len }\end{DoxyParamCaption})}



Sends a packet or sends the the contents of the send queue. 

Attempts to send data via the whatever device is passed in \mbox{\hyperlink{netpktce_8h_a49f3c0ed09ccd67b4f0345e99ed4471d}{pl\+\_\+\+Set\+Device()}}. Determines the maximum packet size, and breaks the input into multiple frames. Each \char`\"{}frame\char`\"{} starts a blocking asyncronous event handler with a timeout of 50ms, giving the device time to clear out any backlog in the send buffer. After this timeout, a 3-\/byte size word, followed by the frame data is written to the output buffer.


\begin{DoxyParams}{Parameters}
{\em data} & Pointer to the buffer containing the packet to send. Alternatively, {\bfseries{NULL}} to send the queue. \\
\hline
{\em len} & The length of the packet at {\bfseries{data}}. Can be 0 if {\bfseries{data}} is NULL. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The length of the packet sent. Will loop sending multiple packet frames until the passed buffer or queue is fully sent or an error occurs. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
If at any point a frame reports that the number of bytes sent does not match what is expected, an error, namely buffer limit, is assumed to have occured. The packet send loop immediately breaks, returning the size that was successfully sent. It is up to the user if it is important to them to check for and possibly handle this error condition or if it can simply be ignored. 
\end{DoxyNote}
\mbox{\Hypertarget{netpktce_8h_a2c78695f43c39502f3e01928acd0571b}\label{netpktce_8h_a2c78695f43c39502f3e01928acd0571b}} 
\index{netpktce.h@{netpktce.h}!pl\_ReadPacket@{pl\_ReadPacket}}
\index{pl\_ReadPacket@{pl\_ReadPacket}!netpktce.h@{netpktce.h}}
\doxysubsubsection{\texorpdfstring{pl\_ReadPacket()}{pl\_ReadPacket()}}
{\footnotesize\ttfamily bool pl\+\_\+\+Read\+Packet (\begin{DoxyParamCaption}\item[{uint8\+\_\+t $\ast$}]{dest }\end{DoxyParamCaption})}



Reads a number of bytes from the subsystem. 


\begin{DoxyParams}{Parameters}
{\em dest} & Pointer to a buffer to read bytes to. Must be large enough to hold the largest packet your application uses. \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
This function defaults to a non-\/blocking read, meaning it checks if there is a full packet available in the receive buffer and then immediately returns to the caller. You may set this to a blocking read by using the \mbox{\hyperlink{netpktce_8h_a3eee61cca8169f57e0f216e562012aa6}{pl\+\_\+\+Set\+Read\+Timeout()}} function. 
\end{DoxyNote}
\begin{DoxyReturn}{Returns}
True if a packet is available. False if not. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Because the packet header contains a size word, there is no need to pass a read size. The protocol will alternate between attempting to read a {\bfseries{size\+\_\+t}} (3 bytes) and attempting to read the length the last size\+\_\+t indicated. 

Like the send function, the read function can also support packet overflow, but it handles it differently. In this case, once the expected size is known, the library will attempt to read the {\bfseries{least}} of either\+: the expected size or the receive buffer length. After performing the read, it will reduce the expected size by the last read. If the expected size is now 0, the packet is complete, and it awaits a new size. However, if the expected size is still non-\/zero, it continues to await more packet data until the expected size is reached. 
\end{DoxyNote}
\mbox{\Hypertarget{netpktce_8h_ad8675f6b874c0de4ef902363e22441dd}\label{netpktce_8h_ad8675f6b874c0de4ef902363e22441dd}} 
\index{netpktce.h@{netpktce.h}!pl\_SetAsyncTimeout@{pl\_SetAsyncTimeout}}
\index{pl\_SetAsyncTimeout@{pl\_SetAsyncTimeout}!netpktce.h@{netpktce.h}}
\doxysubsubsection{\texorpdfstring{pl\_SetAsyncTimeout()}{pl\_SetAsyncTimeout()}}
{\footnotesize\ttfamily void pl\+\_\+\+Set\+Async\+Timeout (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{timeout }\end{DoxyParamCaption})}



Sets the timeout for the Async device process handler. 

\begin{DoxyNote}{Note}
The async handler is invoked once when \mbox{\hyperlink{netpktce_8h_a4938b78991b6ce642e2e289db0183bc4}{pl\+\_\+\+Send\+Packet()}} is called. It can also be invoked by the user after returning \mbox{\hyperlink{netpktce_8h_ae58df8f84f50f72a2c62bd452d58a3ab}{pl\+\_\+\+Get\+Async\+Proc\+Handler()}}. 

Async timeout defaults to 50ms but can be altered by the user via this function. 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em timeout} & The timeout to set, in milliseconds. Pass 0 to set non-\/blocking. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{netpktce_8h_a3eee61cca8169f57e0f216e562012aa6}\label{netpktce_8h_a3eee61cca8169f57e0f216e562012aa6}} 
\index{netpktce.h@{netpktce.h}!pl\_SetReadTimeout@{pl\_SetReadTimeout}}
\index{pl\_SetReadTimeout@{pl\_SetReadTimeout}!netpktce.h@{netpktce.h}}
\doxysubsubsection{\texorpdfstring{pl\_SetReadTimeout()}{pl\_SetReadTimeout()}}
{\footnotesize\ttfamily void pl\+\_\+\+Set\+Read\+Timeout (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{timeout }\end{DoxyParamCaption})}



Sets the timeout for reading a packet. 

\begin{DoxyNote}{Note}
The packet read timeout defaults to 0, or non-\/blocking, but can be altered by the user via this function. 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em timeout} & The timeout to set, in milliseconds. Pass 0 to set non-\/blocking. \\
\hline
\end{DoxyParams}
